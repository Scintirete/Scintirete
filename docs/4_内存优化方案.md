# Scintirete 内存优化长期方案

## 概述

本文档详细描述了 Scintirete 向量数据库的内存优化策略，包括已实施的立即优化措施和未来的长期优化计划。目标是将运行时内存从当前的 1GB（对应 300MB RDB文件）降低到更合理的 400-600MB 范围。

## 已实施的优化 ✅

### 1. HNSW 连接存储优化

**问题**: 使用 `map[uint64]struct{}` 存储节点连接关系，每个 map 至少有 248 字节的开销。

**解决方案**: 改为使用 `[]uint64` 直接存储连接 ID 列表。

**代码变更**:
```go
// 优化前
type HNSWNode struct {
    Connections []map[uint64]struct{}
}

// 优化后  
type HNSWNode struct {
    Connections [][]uint64
}
```

**内存节省**: 50-70% 的图结构内存使用，预计节省 200-300MB。

### 2. 减少深度拷贝

**问题**: `ExportGraphState()` 和 `ImportGraphState()` 进行大量不必要的深度拷贝。

**解决方案**:
- 向量数据直接引用，避免拷贝
- 元数据直接引用（假设为只读）
- 只拷贝连接关系的结构，不拷贝内容

**内存节省**: 150-200MB，特别是在RDB导入/导出过程中。

### 3. 精确内存使用计算

**改进**: 更新 `updateMemoryUsage()` 方法，准确计算新数据结构的内存开销。

```go
// 新的内存计算方法
func (h *HNSW) updateMemoryUsage() {
    for _, node := range h.nodes {
        // 向量数据: 4字节 × 维度
        usage += int64(len(node.Vector) * 4)
        
        // 连接存储: slice header (24字节) + 每个连接 8字节
        for _, connections := range node.Connections {
            usage += int64(24 + len(connections)*8)
        }
        
        // ... 其他精确计算
    }
}
```

## 中期优化计划 🔄

### 1. 向量数据压缩 (预期节省: 300-400MB)

**实施时间**: 2-3个月

**方案**: 
- 实现可选的 float16 存储格式
- 添加向量量化选项
- 在精度和内存之间提供平衡

```go
type VectorStorage struct {
    Format     StorageFormat // Float32, Float16, Quantized
    Data       []byte        // 压缩后的数据
    Dimension  int
    Scale      float32       // 量化缩放因子
}
```

### 2. 内存池化重用 (预期节省: 50-100MB)

**实施时间**: 1-2个月

**方案**: 使用对象池减少 GC 压力和内存分配

```go
var (
    nodePool = sync.Pool{
        New: func() interface{} { return &HNSWNode{} },
    }
    vectorPool = sync.Pool{
        New: func() interface{} { return make([]float32, 0, 1536) },
    }
)
```

### 3. 分层存储策略 (预期节省: 100-200MB)

**实施时间**: 3-4个月

**方案**: 
- 热数据保留在内存
- 冷数据移动到磁盘
- 实现 LRU 缓存策略

```go
type TieredNode struct {
    ID          uint64
    Vector      *VectorRef    // 可能指向内存或磁盘
    LastAccess  time.Time
    Connections [][]uint64
}

type VectorRef struct {
    InMemory   bool
    MemData    []float32     // 热数据
    DiskOffset int64         // 冷数据磁盘偏移
}
```

### 4. 流式 RDB 加载 (预期节省: 100-200MB)

**实施时间**: 2个月

**方案**: 避免一次性加载所有数据到内存

```go
func (r *RDBManager) LoadStreaming(ctx context.Context, 
    handler func(*CollectionSnapshot) error) error {
    // 逐个集合流式加载，避免全部数据同时在内存
}
```

## 高级优化计划 ⚡

### 1. 内存映射文件 (预期节省: 200-400MB)

**实施时间**: 6个月

**方案**: 使用 mmap 将大型向量数据映射到虚拟内存

```go
type MappedVectorStorage struct {
    File     *os.File
    Mapping  []byte
    Vectors  []VectorView  // 轻量级视图
}
```

### 2. 增量加载机制 (预期节省: 300-500MB)

**实施时间**: 8个月

**方案**: 
- 按需加载向量数据
- 智能预测和预加载
- 细粒度的内存管理

### 3. SIMD 优化 (性能提升)

**实施时间**: 4个月

**方案**: 使用 SIMD 指令优化向量计算，减少临时内存分配

## 配置调优建议

### AOF 缓冲区优化

**当前配置**:
```toml
# configs/scintirete.toml
[persistence]
aof_sync_strategy = "no"  # 已优化，减少 I/O 开销
```

**建议调整**:
```go
// 将 AOF 缓冲区从 64KB 降低到 4KB
bufferThreshold: 4 * 1024  // 4KB instead of 64KB
```

### HNSW 参数调优

**当前配置**:
```toml
[algorithm.hnsw_defaults]
m = 16                # 保持不变
ef_construction = 200 # 考虑降低到 150
ef_search = 50        # 保持不变
```

**内存影响**: 降低 `ef_construction` 可以减少构建时的临时内存使用。

## 监控和测量

### 内存使用监控

1. **实时监控**:
   ```go
   // 使用 runtime.MemStats 监控
   var m runtime.MemStats
   runtime.GC()
   runtime.ReadMemStats(&m)
   ```

2. **自定义指标**:
   ```go
   type MemoryMetrics struct {
       VectorDataMemory    int64
       GraphStructMemory   int64
       PersistenceMemory   int64
       SystemOverhead      int64
   }
   ```

### 性能基准测试

定期运行基准测试以验证优化效果：

```bash
# 内存使用基准
go test -bench=BenchmarkMemoryUsage -memprofile=mem.prof

# 分析内存热点
go tool pprof mem.prof
```

## 实施路线图

| 时间段 | 优化项目 | 预期内存节省 | 实施优先级 |
|--------|----------|--------------|------------|
| 已完成 | 连接存储优化 | 200-300MB | ✅ 高 |
| 已完成 | 减少深度拷贝 | 150-200MB | ✅ 高 |
| 1-2月 | 内存池化 | 50-100MB | 🔄 中 |
| 2-3月 | 向量压缩 | 300-400MB | 🔄 高 |
| 2-3月 | 流式加载 | 100-200MB | 🔄 中 |
| 3-4月 | 分层存储 | 100-200MB | 🔄 中 |
| 4-6月 | SIMD优化 | 性能提升 | 🔄 低 |
| 6-8月 | 内存映射 | 200-400MB | ⏳ 低 |

## 风险评估

### 低风险优化
- ✅ 连接存储优化 (已完成)
- ✅ 减少深度拷贝 (已完成)
- 🔄 内存池化
- 🔄 流式加载

### 中等风险优化
- 🔄 向量压缩 (可能影响精度)
- 🔄 分层存储 (复杂度增加)

### 高风险优化
- ⏳ 内存映射 (平台相关性)
- ⏳ 增量加载 (架构变更较大)

## 总结

通过已实施的立即优化措施，预计可以节省 **350-500MB** 内存使用。结合中期和长期优化计划，最终目标是将 1GB 运行内存降低到 **400-600MB** 范围，实现 **40-60%** 的内存使用优化。

这将显著改善系统在资源受限环境下的表现，特别是在容器化部署和边缘计算场景中。

---

*最后更新: 2024年1月*
*负责人: 系统架构团队*
